convert c: #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
to fb:     #define lua_pushliteral(L, s) lua_pushlstring(L, "" s, len(s)-1)

convert c: #define luaL_newlibtable(L,l) lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)
to fb:     #define luaL_newlibtable(L, l_) lua_createtable(L, 0, (ubound(l_) - lbound(l_) + 1) - 1)

convert c: #define luaL_argcheck(L, cond,numarg,extramsg) ((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
to fb:
	#macro luaL_argcheck(L, cond, numarg, extramsg)
		if (cond) = 0 then
			luaL_argerror(L, (numarg), (extramsg))
		end if
	#endmacro

convert c: #define luaL_dofile(L, fn) (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
to fb:
	private function luaL_dofile(byval L as lua_State ptr, byval fn as const zstring ptr) as long
		function = (luaL_loadfile(L, fn) orelse lua_pcall(L, 0, LUA_MULTRET, 0))
	end function

# This is a function, so it can be used as statement, ignoring the result.
# (FB would otherwise disallow that, due to the ORELSE)
convert c: #define luaL_dostring(L, s) (luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
to fb:
	private function luaL_dostring(byval L as lua_State ptr, byval s as const zstring ptr) as long
		function = (luaL_loadstring(L, s) orelse lua_pcall(L, 0, LUA_MULTRET, 0))
	end function

convert c: #define luaL_addchar(B,c) ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), ((B)->b[(B)->n++] = (c)))
to fb:
	#macro luaL_addchar(B,c)
		if (B)->n >= (B)->size then
			luaL_prepbuffsize((B), 1)
		end if
		(B)->b[(B)->n] = (c)
		(B)->n += 1
	#endmacro
